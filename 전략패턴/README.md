### 1장 - 전략패턴

객체들의 `역할`을 정의하고 변화하는 `역할을 분리하는 캡슐화`를 통해 각각의 역할들을 수정해서 쓸 수 있게 해줍니다. 전략패턴을 사용하면 객체의 역할을 동적으로 바꾸고 싶은 경우 직접 코드를 수정하지 않고 전략(해당 역할을 수행하는 객체)을 바꾸는 것만으로 역할을 수정할 수 있도록 만든 패턴이다.

로그인을 할 때에 id/pw로 로그인하는 일반 로그인 방식과 네이버나 카카오같은 소셜 로그인 방식도 이 전략 패턴을 적용한 하나의 예시라고 볼 수 있겠다.

#### 상속과 Composition(구성/합성)

상속은 `is-a` 관계로 정의될 수 있으며, 하위 클래스가 상위 클래스의 속성과 동작을 `재사용/확장`하는 개념입니다. Composition은 `has-a` 관계로 정의될 수 있으며, 한 클래스가 다른 클래스의 객체를 `포함`하는 개념입니다

상속을 통해 상위 클래스에서 정의한 속성과 동작을 재사용할 수 있으며 오버로딩/오버라이딩을 통해 다형성을 구현할 수 있지만, 상위 클래스와 하위 클래스의 높은 결합으로 인해 하나의 수정 사항에도 여러 코드에 수정을 가할 수 있는 문제점이 있을 수 있습니다.

가령 `Duck 클래스`를 상속받는 다른 종류의 Duck에서 Duck 클래스에서 상속받은 메서드를 사용하지 않으려면 오버라이딩을 통해 `return null`과 같이 변경해줘야 하고, 이러한 변화가 많으면 전부 변경해줘야 합니다. 이는 캡슐화를 깨트릴 수 있고, 상속 관계가 복잡해질 수 있음을 보여주죠.

Composition은 객체를 여러 책임과 역할을 같은 다른 객체들의 협력으로 표현하는 것 입니다. 상속이 아닌 다른 객체들의 협력으로 객체를 구성하기 때문에 인터페이스를 통해 객체를 조합할 수 있고, 이는 느슨한 결합을 만들죠. 덕분에 유연하고 재사용 가능한 설계를 가능하게 만듭니다.

단점은 객체간의 의존성이 증가함에 따라 코드가 복잡해질 수 있다는 것 입니다. 모든 객체의 인터페이스를 파악해야하는 문제도 있겠지만, 복잡한 코드를 이해하는 것 보다 인터페이스를 이해하는쪽이 더 쉽겠죠?

## 사용해보기

```typescript
// 기존의 코드 before.js
class Animal {
  sound: string;

  constructor(sound: string) {
    this.sound = sound;
  }

  eat() {
    console.log("와구 와구 먹습니다.");
  }

  walk() {
    console.log("뚜벅 뚜벅 걷습니다.");
  }

  cry() {
    console.log(`${this.sound}하고 웁니다`);
  }
}
// 상속을 바탕으로 구현
class Dog extends Animal {}
class Cat extends Animal {}
```

#### 물고기나 새와 같은 다른 행동을 갖는 동물들이 추가되면?
상속을 바탕으로 코드를 **`재사용`** 할 수 있다는 점은 굉장히 훌륭합니다. 하지만 확장과 변화에는 유연하지 못합니다.

위의 예시처럼 물고기나 새와 같은 다른 행동을 갖는 동물이 추가된다면, 물고기는 울지(cry)않기 때문에 `cry()` 메서드를 **`오버라이드`** 해줘야 합니다. 또한, 새는 날 수 있기 때문에 Animal 클래스 자체에 `fly()` 메서드를 추가하고, 나머지 다른 동물들에는 fly() 메서드를 따로 오버라이드 해줘야 합니다.

이처럼 상속은 부모 클래스에서 자식 클래스로 모든 메서드를 전달함에 있어 강제성이 있어 수정과 확장에 있어 사실상 고칠 필요가 없는 부분들도 고쳐야하기 때문에 변화에 유연하지 못합니다. 물론 새에만 fly() 메서드를 추가할 수 있지만, 새 말고도 다른 동물들이 마찬가지로 날 수 있기 때문에 코드를 재사용할 수 없는 문제가 발생.

상속(is-a) 대신 합성(has-a)를 통해 구현하자!
객체가 해당 객체의 특성을 갖는!!!

상속은 이해하기 쉽지만, 높은 결합도를 갖고 있어 그 구조가 쉽게 망가질 수 있다.

```typescript
// 구성으로 개선한 코드 after.js
class Dogg {
  animal: Animall;
  cryable: Cryable;
  walkable: Walkable;
  swimmable: SwimBehavior;

  constructor(sound: string) {
    this.animal = new Animall();
    this.cryable = new Cryable(sound);
    this.walkable = new Walkable();
    this.swimmable = new Swimmable();
  }
}
```

Dog 객체가 갖고 있는 행동들을 따로 선언해줌으로써 수정이나 확장에 유연한 구조로 변경되었습니다.

이런 구성 구조를 바탕으로 객체를 생성하면 객체의 행동을 동적으로 변경할 수 있습니다. 앞서 디자인 원칙에서 변화하는 행동을 분리하여 캡슐화한다고 했습니다. 여기서는 Dogg 객체의 `swim()` 메서드가 변화할 수 있다고 해보겠습니다.

```typescript
interface SwimBehavior {
  swim: () => void;
}

class Swimmable implements SwimBehavior {
  swim() {
    console.log("물살을 가로지르며 헤엄칩니다");
  }
}

class SwimWithRocket implements SwimBehavior {
  swim() {
    console.log("로켓 엔진을 장착해서 수영합니다. 정말 빨라요!");
  }
}
```

Dogg 객체는 일반적인 SwimBehavior라는 인터페이스를 갖고 이러한 동작을 할 수 있다면 동일한 객체라고 판단하는 `다형성`의 특징을 사용하여 전략 패턴을 구성할 수 있습니다. 이렇게 말이죠!

```typescript
puppy.swimmable.swim(); // 물살을 가로지르며 헤엄칩니다
puppy.swimmable = new SwimWithRocket(); // 행동을 변경!
puppy.swimmable.swim(); // 로켓 엔진을 장착해서 수영합니다. 정말 빨라요!
```
이렇게 구성을 사용하면 실행 중간에도 객체의 동작을 동적으로 변경할 수 있습니다. 물론, 지금은 직접 `객체의 state`에 접근하여서 변경했지만 사실 객체의 속성에 직접 접근하는 것은 복잡도를 키울 수 있기 때문에 setter 메서드를 통해 객체의 state를 변경하는 메서드를 제공해주면 더 좋은 코드가 될 수 있겠네요!

이것으로 전략 패턴을 마치도록 하겠습니다!

